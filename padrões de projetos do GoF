1 – Prototype - criação de objetos
Intenção 
Especificar os tipos de objetos a serem criados usando uma instância-protótipo e criar novos objetos pela cópia desse protótipo.
Aplicabilidade 
Use o padrão Prototype quando um sistema tiver que ser independente de como os seus produtos são criados, compostos e representados; e • quando as classes a instanciar forem especificadas em tempo de execução, por exemplo, por carga dinâmica; ou • para evitar a construção de uma hierarquia de classes de fábricas paralela à hierarquia de classes de produto; ou • quando as instâncias de uma classe puderem ter uma dentre poucas combinações diferentes de estados. Pode ser mais conveniente instalar um número correspondente de protótipos e cloná-los, ao invés de instanciar a classe manualmente, cada vez com um estado apropriado.
 
Participantes
 • Prototype (Graphic) – declara uma interface para clonar a si próprio. • ConcretePrototype (Staff, Whole Nota, Half Note) – implementa uma operação para clonar a si próprio. • Client (GraphicTool) – cria um novo objeto solicitando a um protótipo que clone a si próprio.

Colaborações
 • Um cliente solicita a um protótipo que este clone a si próprio.
Conseqüências
 Prototype tem muitas das mesmas conseqüências que Abstract Factory (95) e Builder (104) têm: ele oculta as classes de produtos concretas do cliente, desta forma reduzindo o número de nomes que os clientes necessitam saber. Além disso, esses padrões permitem a um cliente trabalhar com classes específicas de uma aplicação sem necessidade de modificação. Os benefícios adicionais do padrão Prototype estão relacionados abaixo. 1. Acrescenta e remove produtos em tempo de execução. Prototype permite incorporar uma nova classe concreta de produto a um sistema, simplesmente registrando uma instância protótipo com o cliente. Isso é um pouco mais flexível do que outros padrões de criação, porque o cliente pode instalar e remover protótipos em tempo de execução. 2. Especifica novos objetos pela variação de valores. Sistemas altamente dinâmicos permitem definir novos comportamentos através da composição de objetos – por exemplo, pela especificação de valores para as variáveis de um objeto – e não pela definição de novas classes. Você efetivamente define novos tipos de objetos pela instanciação das classes existentes e registrando as instâncias como protótipos dos objetos-clientes. Um cliente pode exibir um novo comportamento através da delegação de responsabilidades para o protótipo.
Esse tipo de projeto permite aos usuários definir novas “classes” sem ter que programar. De fato, clonar um protótipo é semelhante a instanciar uma classe. O padrão Prototype pode reduzir grandemente o número de classes que um sistema necessita. No nosso editor musical, uma classe GraphicTool pode criar uma variedade ilimitada de objetos musicais. 3. Especifica novos objetos pela variação da estrutura. Muitas aplicações constróem objetos com partes e subpartes. Por exemplo, editores para o projeto de circuitos que constroem circuitos a partir de subcircuitos.1 Por questões de conveniência, tais aplicações freqüentemente permitem instanciar estruturas complexas, definidas pelo usuário, para, por exemplo, usar um subcircuito específico repetidas vezes. O padrão Prototype também suporta isso. Simplesmente adicionamos esse subcircuito como um protótipo à paleta dos elementos de circuitos disponíveis. Contanto que o objeto-circuito composto implemente um clone por replicação (deep copy), circuitos com diferentes estruturas podem ser protótipos. 4. Reduz o número de subclasses. O Factory Method (112) freqüentemente produz uma hierarquia de classes Creator paralela à hierarquia de classes do produto. O padrão Prototype permite clonar um protótipo em vez de pedir a um método fábrica para construir um novo objeto. Daí não necessitar-se de nenhuma hierarquia de classes Creator. Esse benefício se aplica primariamente a linguagens como C++, que não tratam as classes como objetos de primeira classe. As linguagens que assim o fazem, como Smalltalk e Objective C, obtêm menos benefícios, uma vez que sempre se usa um objeto-classe como um criador. Objetos-classe já funcionam como protótipos nessas linguagens. 5. Configura dinamicamente uma aplicação com classes. Alguns ambientes de tempo de execução permitem carregar classes dinamicamente numa aplicação. O padrão Prototype é a chave para a exploração de tais possibilidades numa linguagem como C++. Uma aplicação que quer criar instâncias de uma classe dinamicamente carregada não será capaz de referenciar o seu constructor estaticamente. Em vez disso, o ambiente de tempo de execução cria uma instância de cada classe automaticamente, quando carregada, e registra a instância junto a um gerenciador de protótipo (ver a seção Implementação). Então, a aplicação pode solicitar ao gerenciador de protótipos instâncias de classes recémcarregadas, classes essas que originalmente não estavam “linkadas” ao programa. O framework de aplicações da ET++ [WGM88] tem um sistema de tempo de execução que usa este esquema.
O principal ponto fraco do padrão Prototype é que cada subclasse de Prototype deve implementar a operação Clone, o que pode ser difícil. Por exemplo, acrescentar Clone é difícil quando as classes consideradas já existem. A implementação de Clone pode ser complicada quando uma estrutura interna dessas classes inclui objetos que não suportam operação de cópia ou têm referências circulares.

Implementação
 Prototype é particularmente útil com linguagens estáticas como C++, na qual as classes não são objetos, e pouca ou nenhuma informação sobre tipos está disponível em tempo de execução. Ele é menos importante em linguagens como Smalltalk ou Objective C, que fornecem o equivalente a um protótipo (ou seja, um objeto-classe) para criação de instâncias de cada classe. Este padrão está incorporado em linguagens baseadas em protótipos como a Self [US87], na qual toda a criação de objetos se dá pela clonagem de um protótipo. Ao implementar protótipos levam-se em consideração os seguintes aspectos:
1.	Usar um gerenciador de protótipos. Quando o número de protótipos num sistema não é fixo (ou seja, eles podem ser criados e destruídos dinamicamente), é importante manter um sistema de registro dos protótipos disponíveis. Os clientes não vão gerenciar os protótipos, mas farão sua armazenagem e recuperação pelo sistema de registro. Um cliente solicitará um protótipo ao sistema de registro antes de cloná-lo. Nós chamamos esse sistema de registro de gerenciador de protótipos. Um gerenciador de protótipos é uma memória associativa que retorna o protótipo correspondente a uma chave fornecida. Ele tem operações para registrar um protótipo com uma chave e para removê-lo do registro. Os clientes podem mudar ou mesmo pesquisar o registro em tempo de execução. Isso permite aos clientes estenderem e fazerem um inventário do sistema sem necessidade de escrever linhas de código. 2. Implementar a operação Clone. A parte mais difícil do padrão Prototype é a implementação correta da operação Clone. Ela é particularmente difícil quando as estruturas de objetos contêm referências circulares. A maioria das linguagens fornece algum suporte para clonagem de objetos. Por exemplo, Smalltalk fornece uma implementação de copy que é herdada por todas as subclasses de Object. C++ fornece um constructor copy. Mas estes recursos não resolvem o problema shallow copy versus deep copy (cópia por referência versus cópia por replicação) [GR83]. Ou seja, clonar objetos significa clonar suas variáveis de instância, ou o clone e o original simplesmente compartilham as variáveis? Uma shallow copy é simples e, na maior parte das vezes, suficiente, e é o que o Smalltalk fornece por omissão. O constructor de cópias por omissão em C++ faz uma cópia membro a membro, o que significa que os apontadores serão compartilhados entre a cópia e o original. Porém, clonar protótipos com estruturas complexas normalmente exige uma cópia por replicação (deep copy), porque o clone e o original devem ser independentes. Portanto, você deve garantir que os componentes do clone são clones dos componentes do protótipo. A clonagem força a decidir o que, se for o caso, será compartilhado. Se os objetos no sistema fornecem operações de Salvar e Carregar, então você pode usá-las para fornecer uma implementação por omissão de Clone simplesmente salvando o objeto e carregando-o de volta imediatamente. A operação Salvar salva o objeto num buffer de memória, e a operação Carregar cria uma cópia por reconstrução do objeto a partir do buffer. 3. Iniciar clones. Enquanto alguns clientes ficam perfeitamente contentes com o clone tal como ele é, outros desejarão iniciar alguns ou todos os seus estados internos com valores de sua escolha. Você geralmente não pode passar esses valores para operação Clone porque o seu número variará entre as classes de protótipo. Alguns protótipos podem necessitar de múltiplos parâmetros de inicialização; outros não necessitarão de nenhum. Passar parâmetros para a operação Clone impede uma interface uniforme de clonagem. Pode ser que suas classes-protótipo já definam operações para (re)estabelecer estados-chave. Caso isso aconteça, os clientes podem usar essas operações imediatamente após a clonagem. Se isso não acontecer, então você pode ter que introduzir uma operação Initialize(ver a seção de Exemplo de Código) que recebe parâmetros de inicialização como argumentos e estabelece o estado interno do clone de acordo. Cuidado com as operações clone que usam replicação (deep copying) – as cópias podem ter que ser deletadas (ou explicitamente, ou dentro de Initialize) antes de você reinicializá-las.
EXEMPLO DE CÓDIGO
Definiremos uma subclasse MazePrototypeFactory da classe MazeFactory (página 100). MazePrototypeFactory será iniciada com protótipos dos objetos que criará, de maneira que não tenhamos que criar subclasses somente para mudar as classes de paredes ou salas que ela cria. A MazePrototypeFactory aumenta a interface de Maze Factory com um constructor que aceita os protótipos como argumentos:


Class MazePrototypeFactory : public MazeFactory {
Public:
	MazePrototypeFactory (Maze*, Wall*, Room*, Door*);

Virtual Maze* MakeMaze () const;
Virtual Room* MakeRoom(int) const;
Virtual Wall* MakeWall () const;
Virtual Door* MakeDoor (Room*, Room*) const;

Private:
	Maze* _prototypeMaze;
	Room* _prototypeRoom;
	Wall* _prototypeWall;
	Door* _prototypeDoor;
}

O novo construtor simplesmente inicia seus protótipos:

MazePrototypeFactory: :MazePrototypeFactory (
	Maze* m, Wall* w, Room * r, Door* d
) {
    _prototypeMaze = m;
    _prototypeWall = w;
    _prototypeRoom = r;
    _prototypeDoor = d;
}

As funções-membro para a criação de paredes, salas e portas são semelhantes: cada uma clona um protótipo e então o inicia. Aqui estão as definições de MakeWall e MakeDoor:

Wall* MazePrototypeFactory: :MakeWall () const {
	Return _prototypeWall->Clone ( );
}

Door* MazePrototypeFactory: :MakeDoor (Room* r1, Room *r2) const {
	Door* door = _prototypeDoor->Clone ( );
	door->Initialize (r1, r2);
	return door;
}

Podemos usar MazePrototypeFactory para criar um labirinto-protótipo (ou um labirinto por omissão) simplesmente iniciando-o com protótipos dos componentes básicos de labirinto: 

MazeGame game;
MazePrototypeFactory simpleMazeFactory (
	new Maze, new Wall, new Room, new Door
) ;
Maze* maze = game.CreateMaze (simpleMazeFactory);

Para mudar o tipo de labirinto, iniciamos MazePrototypeFactory com um conjunto diferente de protótipos. A seguinte chamada cria um labirinto com uma BombedDoor e um RoomWithABomb:

MazePrototypeFactory bombedMazeFactory (
	new Maze, new BombedWall,
	new RoomWithABomb, new Door
);

	virtual void Enter ( );
	Room* OtherSideFrom (Room*);
Private:
	Room* _room1;
	Room* _room2;
);

Door: :Door (const Door& other)  {
	_room1 = other._room1;
	_room2 = other._room2;
)

void Door: : Initialize (Room* r1, Room* r2) {
	__room1 = r1;
	_room2 = r2;
}

Door* Door: : Clone ( ) const {
	return new Door (*this);
}

A subclasse BombedWalldeve redefinir Clone e implementar um constructor de cópias correspondente.

class BombedWall : public Wall {
public:
	BombedWall ( );
	BombedWall (const BombedWall&);

virtual wall * Clone ( ) const;  
bool HasBomb ( );
private:
	bool _bomb;
};

BombedWall : : BombedWall (const BombedWall& other) : Wall (other) {
	_bomb = Other._bomb;
}

Wall* BombedWall : : Clone ( ) const {
	return new BombedWall (*this);
}

Embora BombedWall::Clone retorne um Wall*, sua implementação retorna um ponteiro para uma nova instância de uma subclasse, qual seja, um BombedWall*. Definimos Clone desta maneira na classe-base para nos assegurarmos de que os clientes que clonam o protótipo não tenham que conhecer suas subclasses concretas. Clientes nunca deveriam precisar fazer um downcast do valor de retorno de Clone para o tipo desejado.
Em Smalltalk, você pode reutilizar o método-padrão copy herdado de Object para clonar qualquer MapSite. Você pode usar MazeFactory para produzir os protótipos de que necessita; por exemplo, pode criar uma sala fornecendo o nome #room.
om. A MazeFactory (fábrica de labirintos) tem um dicionário que mapeia nomes aos protótipos. Seu método make: se parece com o seguinte: 

	make: partName
		(partCatalog at: partname) copy  

Tendo métodos apropriados para inicia a MazeFactory com protótipos, você poderia criar um labirinto simples com o seguinte código:

CreateMaze
	on: (MazeFactory new
	       with Door new named: #door;
                   with: Wall new named: #wall;
                   with: Room new named: #room;
                    yourself)

onde a definição do método de classe on: para CreateMaze seria

on: aFactory
	| room1 room2 |
	room1 : = (aFactory make: #room) location: 101.
 	room2 : = (aFactory make: #room) location: 201.
	door := (aFactory make: #door) from: room1 to: room2.

room1
	atSide: #north put: (aFactory make: #wall);
	atSide: #east put: door;
	atSide: #south put: (aFactory make: #wall);
	atSide: #west put: (aFactory make: #wall).
room2
	atSide: #north put: (aFactory make: #wall);
	atSide: #east put: (aFactory make: #wall);
	atSide: #south put: (aFactory make: #wall);
	atSide: #west put: door.
      ^  Maze new
	addRoom: room1;
	addRoom: room2;
	yourself

Usos conhecidos

Talvez o primeiro exemplo do padrão Prototype se encontre no sistema Sketchpad de Ivan Sutherland [Sut63]. A primeira aplicação amplamente conhecida do padrão numa linguagem orientada a objeto foi em ThingLab, na qual os usuários poderiam formar um objeto composto e então promovê-lo a um protótipo pela sua instalação numa biblioteca de objetos reutilizáveis [Bor81]. Goldberg e Robson mencionam protótipos como um padrão [GR83], mas Coplien [Cop92] fornece uma descrição muito mais completa. Ele descreve idiomas relacionados ao padrão prototype para C++ e dá muitos exemplos e variações.
O Etgdb é um depurador (debugger) de front-end, baseado em ET++, que fornece uma interface de apontar e clicar para diferentes depuradores orientados a linhas. Cada depurador tem uma subclasse DebuggerAdaptor correspondente. Por exemplo, GdbAdaptor adapta o etgdb à sintaxe dos comandos do gdb de GNU, enquanto que SunDbxAdaptor adapta o etgdb ao depurador da Sun. O Etgdb não tem um conjunto de classes DebuggerAdaptor codificadas rigidamente nele próprio. Em vez disso, lê o nome do adaptor a ser usado de uma variável fornecida pelo ambiente, procura um protótipo com o nome especificado em uma tabela global e, então, clona o protótipo. Novos depuradores podem ser acrescentados ao etgdb ligando-o ao DebuggerAdaptor que funciona para um depurador novo. 
A “biblioteca de técnicas de interações”, no ModeComposer, armazena protótipos de objetos que suportam várias técnicas de interação [Sha90]. Qualquer técnica de interação criada pelo Mode Composer pode ser usada como um protótipo colocando-a nesta biblioteca. O padrão Prototype permite ao Mode Composer suportar um conjunto ilimitado de técnicas de interação. O exemplo do editor musical discutido anteriormente se baseia no framework para desenhos do Unidraw [VL90].

Padrões relacionados
Prototype e Abstract Factory (95) são padrões que competem entre si em várias situações, como discutimos no final deste capítulo. Porém, eles também podem ser usados em conjunto. Um Abstract Factory pode armazenar um conjunto de protótipos a partir dos quais podem ser clonados e retornados objetos-produto.
Projetos que utilizam intensamente os padrões Composite (160) e Decorator (170) também podem se beneficiar do uso do Prototype.  

2) SINGLETON criação de objetos

Intenção 
Garantir que uma classe tenha somente uma instância e fornecer um ponto global de acesso para a mesma.
Motivação 
É importante para algumas classes ter uma, e apenas uma, instância. Por exemplo, embora possam existir muitas impressoras em um sistema, deveria haver somente um spooler de impressoras. Da mesma forma, deveria haver somente um sistema de arquivos e um gerenciador de janelas. Um filtro digital terá somente um conversor A/ D. Um sistema de contabilidade será dedicado a servir somente a uma companhia. Como garantimos que uma classe tenha somente uma instância e que essa instância seja facilmente acessível? Uma variável global torna um objeto acessível, mas não impede você de instanciar múltiplos objetos. Uma solução melhor seria tornar a própria classe responsável por manter o controle da sua única instância. A classe pode garantir que nenhuma outra instância seja criada (pela interceptação das solicitações para criação de novos objetos), bem como pode fornecer um meio para acessar sua única instância. Este é o padrão Singleton.
Aplicabilidade
Use o padrão Singleton quando:
• for preciso haver apenas uma instância de uma classe, e essa instância tiver que dar acesso aos clientes através de um ponto bem conhecido; 
• a única instância tiver de ser extensível através de subclasses, possibilitando aos clientes usar uma instância estendida sem alterar o seu código.

 

Participantes

• Singleton – define uma operação Instance que permite aos clientes acessarem sua única instância. Instance é uma operação de classe (ou seja, em Smalltalk é um método de classe e em C++ é uma função-membro estática). – pode ser responsável pela criação da sua própria instância única.

Colaborações
• Os clientes acessam uma instância Singleton unicamente pela operação Instance do Singleton.

Conseqüências

O padrão Singleton apresenta vários benefícios:
1.	Acesso controlado à instância única. Como a classe Singleton encapsula a sua única instância, possui controle total sobre como e quando os clientes a acessam.
2.	Espaço de nomes reduzido. O padrão Singleton representa uma melhoria em relação ao uso de variáveis globais. Ele evita a poluição do espaço de nomes com variáveis globais que armazenam instâncias únicas.
3.	Permite um refinamento de operações e da representação. A classe Singleton pode ter subclasses e é fácil configurar uma aplicação com uma instância dessa classe estendida. Você pode configurar a aplicação com uma instância da classe de que necessita em tempo de execução.
4.	Permite um número variável de instâncias. O padrão torna fácil mudar de idéia, permitindo mais de uma instância da classe Singleton. Além disso, você pode usar a mesma abordagem para controlar o número de instâncias que a aplicação utiliza. Somente a operação que permite acesso à instância de Singleton necessita ser mudada.
5.	Mais flexível do que operações de classe. Uma outra maneira de empacotar a funcionalidade de um singleton é usando operações de classe (ou seja, funções-membro estáticas em C++ ou métodos de classe em Smalltalk). Porém, as técnicas de ambas as linguagens tornam difícil mudar um projeto para permitir mais que uma instância de uma classe. Além disso, as funçõesmembro estáticas em C++ nunca são virtuais, o que significa que as subclasses não podem redefini-las polimorficamente.
Implementação

A seguir apresentamos tópicos de implementação a serem considerados ao usar o padrão Singleton:

1.	Garantindo uma única instância. O padrão Singleton torna a instância única uma instância normal de uma classe, mas essa classe é escrita de maneira que somente uma instância possa ser criada. Uma forma comum de fazer isso é ocultando a operação que cria a instância usando uma operação de classe (isto é, ou uma função-membro estática ou um método de classe) que garanta que apenas uma única instância seja criada. Esta operação tem acesso à variável que mantém a única instância, e garante que a variável seja iniciada com a instância única antes de retornar ao seu valor. Esta abordagem assegura que um singleton seja criado e iniciado antes da sua primeira utilização.
Em C++, você pode definir a operação de classe com uma função-membro estática Instance da classe Singleton. Singleton também define uma variável-membro estática _instance que contém um apontador para sua única instância.
A classe Singleton é declarada como
class Singleton {
public:
	static Singleton* Instance ( );
protected: 
	Singleton (  );
private:
	static Singleton* _instance;
};

A implementação correspondente é a seguinte
Singleton* Singleton: :_instance = 0;
Singleton* Singleton: : Instance ( ) (
	if (_instance == 0) {
                _instance = new Singleton;
}
  	return _instance;
}

Os clientes acessam o singleton através da função membro Instance. A variável _instance é iniciada com 0, e a função-membro estática Instance retorna o seu valor, iniciando-a com a única instância se ele for 0. Instanceusa lazy initialization; o valor que ela retorna não é criado e armazenado até ser acessado pela primeira vez.
Note que o constructor é protegido. Um cliente que tenta instanciar Singleton diretamente obterá como resposta um erro em tempo de compilação. Isto assegura que somente uma instância possa ser criada.
Além do mais, uma vez que _instance é um apontador para um objeto Singleton, a função-membro Instance pode atribuir um apontador para uma subclasse de Singleton para esta variável. Daremos um exemplo do que dissemos aqui na seção Exemplo de código.
Há uma outra coisa a ser observada sobre a implementação em C++. Não é suficiente definir o singleton como um objeto global ou estático, confiando numa inicialização automática. Existem três razões para isto:
(a)	não podemos garantir que somente uma instância de um objeto estático será declarada;
(b)	talvez não tenhamos informação suficiente para instanciar cada singleton em tempo de inicialização estática. Um singleton pode necessitar de valores que são computados mais tarde, durante a execução do programa;
(c)	C++ não define a ordem pela qual os constructors para objetos globais são chamados entre unidades de compilação [ES90]. Isso significa que não podem existir dependências entre singletons; se alguma existir, então é inevitável a ocorrência de erro.
Uma deficiência adicional (embora pequena) da abordagem objeto global/ estático é que ela força a criação de todos singletons, quer sejam usados ou não. O uso de uma função-membro estática evita todos estes problemas.
Em Smalltalk, a função que retorna a instância única é implementada como um método de classe da classe Singleton. Para garantir que somente uma instância seja criada, redefine-se a operação new. A classe Singleton resultante pode ter os seguintes métodos de classe, em que SoleInstance é uma variável de classe que não é usada em nenhum outro lugar:

new
	self error: ‘cannot create new object’
default 
	SoleInstance isNil ifTrue: [SoleInstance := super new].
	^ SoleInstance

2.	Criando subclasses da classe Singleton. O ponto principal não é a definição da subclasse, mas sim a instalação da sua única instância de maneira que os clientes possam ser capazes de usá-la. Em essência, a variável que referencia a instância do singleton deve ser iniciada com uma instância da subclasse. A técnica mais simples é determinar qual singleton você quer usar na operação Instance do Singleton. Um exemplo na seção de Exemplo mostra como implementar essa técnica com variáveis do ambiente (operacional).
Uma outra maneira de escolher a subclasse de Singleton é retirar a implementação de Instance da classe-mãe (por exemplo, MazeFactory) e colocá-la na subclasse. Isto permite a um programador C++ decidir a classe do singleton em tempo de “Linkedição” (link-time), mantendo-a oculta dos seus clientes (por exemplo, fazendo a ligação com um arquivo-objeto que contém uma implementação diferente).
A solução da ligação fixa a escolha da classe do singleton em tempo de “linkedição”, o que torna difícil escolher a classe do singleton em tempo de execução. O uso de instruções condicionais para determinação da subclasse é mais flexível, porém codifica de maneira rígida o conjunto das classes Singleton possíveis. Nenhuma abordagem é flexível o bastante em todos os casos.
Uma abordagem mais flexível utiliza um sistema de registro de singletons (registry of singletons). Em vez de ter Instance definindo o conjunto das classes Singleton possíveis, as classes Singleton podem registrar suas instâncias singleton por nome, num sistema de registro de conhecimento geral.
O sistema de registro associa nomes e singletons. Os nomes são constituídos de cadeias de caracteres. Quando Instance necessita um singleton, ela consulta o sistema de registro, procurando o singleton pelo nome.
O sistema de registro procura o singleton correspondente (se existir) e o retorna ao cliente. Essa solução libera Instance da necessidade de ter que conhecer todas as possíveis classes ou instâncias do Singleton. Tudo o que é necessário é uma interface comum para todas as classes Singleton, que inclua operações de registro:
class Singleton {
public:
	static void Register (const char* name, Singleton*);
	static Singleton* Instance ( );
protected:
	static Singleton* Lookup (const char* name);
private:
	static Singleton* _instance;
	static List<NameSingletonPair>* _registry;
};

Register registra a instância de Singleton com um nome fornecido. Para manter o registro simples, necessitaremos que armazene uma lista de objetos NameSingletonPair. Cada NameSingletonPair mapeia (associa) um nome a um singleton. Dado um nome, a operação Lookup encontra o singleton correspondente. Assumiremos que uma variável do ambiente especifica o nome do singleton desejado.

Singleton* Singleton : : Instance ( ) {
	If (_instance == 00 {
	Const char* singletonName = getenv (*SINGLETON*);
	//usuário ou ambiente fornece esse valor no início da execução

	_instance = Lookup (singletonName);
	// Lookup retorna 0  se não há qualquer singleton com o nome verificado
	}
	return _instance;
}

Onde as classes Singleton registram a si mesmas? Uma possibilidade é fazêlo no seu constructor. Por exemplo, uma subclasse MySingleton poderia fazer o seguinte:
MySingleton : : MySingleton ( ) {
	// ...
	Singleton : : Register (“MySingleton”, this);
}

Naturalmente, o construtor não será chamado a menos que alguém instancie a classe, o que repete o problema que o padrão Singleton está tentando resolver! Nós podemos contornar este problema em C++ através da definição de uma instância estática de MySingleton. Por exemplo, podemos definir 
Static MySingleton theSingleton;
no arquivo que contém a implementação de MySingleton.
A classe Singleton não é mais responsável pela criação do singleton. Em vez disso, sua responsabilidade primária é tornar acessível o objeto singleton escolhido no sistema. A solução que usa o objeto estático ainda apresenta um problema potencial – todas as instâncias de todas as subclasses possíveis de Singleton devem ser criadas, pois, caso contrário, não serão registradas.

Exemplo de código   

Suponha que definimos uma classe MazeFactory para construir labirintos, conforme descrito na página 100. MazeFactory define uma interface para construção de diferentes partes de um labirinto. As subclasses podem redefinir as operações para retornar instâncias de classes-produtos especializadas, tal como BombedWall no lugar de simples objetos Wall.
O fato relevante aqui é que a aplicação Maze necessita somente de uma instância de uma fábrica de labirintos, e que essa instância deverá estar disponível para o código que construir qualquer parte do labirinto. É aí que o padrão Singleton entra. Ao tornar MazeFactory um singleton, nós tornamos o objeto-labirinto (maze) acessível globalmente sem recorrer a variáveis globais.
Para simplificar, suponhamos que nunca criaremos subclasses de MazeFactory (a alternativa será considerada mais à frente). Nós tornamos MazeFactory uma classe Singleton em C++, acrescentando uma operação estática Instance e um membro estático _instancepara conter a única instância existente. Também devemos proteger o constructor para prevenir instanciações acidentais, as quais nos levariam a ter mais que uma instância.
class MazeFactory {
public:
	static MazeFactory* Instance ( );
// interface existente vai aqui
protected:
	MazeFactory ( );
private:
	static MazeFactory* _instance;
};
 A implementação correspondente é
MazeFactory* MazeFactory : :_instance = C
MazeFactory* MazeFactory : : Instance ( ) {
	if (_instance == 0) {
	     _instance = new MazeFactory;
}
return _instance;
}

Agora verificaremos o que acontece quando existem subclasses de MazeFactory e a aplicação tem que decidir qual delas usar. Selecionaremos o tipo de labirinto através de uma variável do ambiente e acrescentaremos o código que instancia a subclasse apropriada de MazeFactory com base no valor da variável do ambiente. Um bom lugar para colocar este código é a operação Instance, porque ela já instancia MazeFactory:
MazeFactory* MazeFactory : : Instance ( ) {
	if (_instance == 0) {
	const char* mazeStyle = getenv (*MAZESTYLE*);
		if (strcmp (MazeStyle, “bombed”) == 0 {
		    _instance = new BombedMazeFactory;
		} else if (strcmp (mazeStyle, “enchanted” == 0) {
		    _instance = new EnchantMazeFactory;
		// ... outras subclasses possíveis
		} else {                   //default
		    _instance = new MazeFactory;
}
		}
		return _instance;
}

Note que Instance deve ser modificada toda vez que você define uma nova subclasse de MazeFactory. Isso pode não ser um problema nesta aplicação, mas pode ser um problema para as fábricas abstratas definidas num framework.
Uma solução possível seria usar a técnica do uso de um sistema de registro descrita na seção Implementação. A ligação dinâmica (dynamic linking) poderia também ser útil aqui – ela evitaria que a aplicação tivesse que carregar para a memória todas as subclasses que não são usadas.

Usos conhecidos 

Um exemplo do padrão Singleton em Smalltalk-80 [Par90] é o conjunto de mudanças no código efetuado por ChangeSet current. Um exemplo mais sutil é o relacionamento entre classes e suas metaclasses. Uma metaclasse é a classe de uma classe, e cada metaclasse tem uma instância. As metaclasses não têm nomes (exceto indiretamente, através do nome da sua única instância), mas registram e acompanham a sua única instância, e normalmente não criarão outra.
O toolkit para construção de interfaces de usuário InterViews [LCI+92] usa o padrão Singleton para acessar as únicas instâncias de suas classes Session e WidgetKit, entre outras. Session define o ciclo de eventos disparáveis da aplicação principal, armazena o banco de dados das preferências de estilo do usuário e administra conexões para um ou mais dispositivos físicos de display. WidgetKit é uma Abstract Factory (95) para definir os widgets de estilo de interação. A operação WidgetKit::instance determina a subclasse específica de WidgetKit que é instanciada baseada numa variável de ambiente que Session define. Uma operação similar em Session determina se são suportados displays monocromáticos ou coloridos e configura a instância singleton de Session de acordo.



